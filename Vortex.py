"""
Code solving the movement of interacting vortices on a grid.

Author: Antoine Belley
Course : Phys 432
Instructor: Eve Lee

Date: 24/02/20
"""
import numpy as np
import matplotlib.pyplot as plt
from numba import jit

class Vortex():
    """Class describing the propriety of a vortex at a given time and computes how to update the position.

    -Methods:*__init__():             Initialize the instance of the vortex and calls the method place_vortex_on_grid() to update the
                                      the velocity at every grid point due to the vortex so that it can be plotted.
             *place_vortex_on_grid(): Updates the attibute 'velcoity_pi' in to modelize the velocity at every grid point of a rankine vortex
                                      around the center of the vortex. Calls the function angular_velocity() to compute the magnitude
                                      and direction of the velocity around the vortex.
             *update()                Update the  velocity of the center of mass of the vortex. Changes in velocity is due to the presence
                                      of other vortices. Uses the forward euler method to solve the ode's for the EOM. With sufficiently small time steps,
                                      this yields satisfactionary results. Could be upgraded to Leapfrog or even adaptative Runge-Kutta,
                                      but I don't have the time right now...

    -Attributes:*k            (float): Constant describing the angular frequency of the vortex.
                *R            (float): Radius of the Rankine vortex.
                *grid          (list): Grid on which the vortex needs to be placed.
                *center       (tuple): x and y coordinatee of the center of the vortex (z not necessary since in the plane).
                *velocity_CM  (array): Velocity in x,y,z of the center of the vortex. Need the three components in order to be able to do cross prodcut in 
                                       method update().
                *velocity_phi (array): Velocity of the fluid at each grid point generated by the vortex.
                *fac            (int): Direction of the vorticity. Either 1 if the vorticity is pointing upward or -1 if it is pointing downward."""


    def __init__(self,R, k, grid,vorticity="up", center=(0,0), velocity_CM =[0,0,0]):
        """Initialize the instance of the vortex and calls the method place_vortex_on_grid() to update the
        the velocity at every grid point due to the vortex so that it can be plotted.

        -Arguments: *self (Vortex object): Instance of the class.
                    *R            (float): The radiuis of the vortex. Vortex is considered to be a Rankine vortex.
                    *k            (float): Constant descriing the angular frequency of the vortex.
                    *grid          (list): Grid on which the vortex needs to be placed.
                    *vorticity   (string): Can be "up" or "down" for the direction of the vorticity with respect
                                           to the plane. Default is "up".
                    *center       (tuple): x and y coordinatee of the center of the vortex. Needs to be on a grid point.
                    *velocity_CM  (array): Velocity of the center of the vortex. Default is [0,0,0]

        -Return : None
        """
        #Initialize the attriutes of the class
        self.R = R
        self.k = k
        self.center = center
        self.grid = grid
        self.velocity_CM = np.array(velocity_CM,dtype=np.float64)
        self.velocity_phi = self.grid.copy()
        #Initialize the attribute fac depending of the vorticity given
        if vorticity == "up":
            self.fac = 1
        elif vorticity=="down":
            self.fac = -1
        #Call method place_vortex_on_grid() in order to compute the velocity at every grid point
        self.place_vortex_on_grid()


    def place_vortex_on_grid(self):
        """Updates the 'velocity_phi' attributes which describe the velocity of the fluid at each grid point (which allows to plot the solution).
        -Arguments: *self (Vortex object): Instance of the class.

        -Return: None"""
        x0, y0 = self.center
        X, Y = self.grid
        r_grid = np.sqrt((X.ravel() - x0)**2 + (Y.ravel() - y0)**2)
        u = np.zeros([2,len(r_grid)]) #Array needs to be defined before being passed to the numba function for memeory management
        u = velocity(r_grid,self.R,u,self.k,X.ravel(), Y.ravel(),self.center)
        u_x = self.fac*u[0].reshape(X.shape)
        u_y = self.fac*u[1].reshape(X.shape)
        self.velocity_phi = u_x, u_y


    def update(self, other_vortices,dt=0.01):
        """Update the position and velocity of the center of the vortex. Changes are due to the effect of neighbouring 
        vortices. The time step is done using the forward Euler method which works well for time steps small enough. Calls 
        the method place_vortex_on_grid() to recompute the velocity of the fluid on every grid point.

        -Arguments: *self  (Vortex object): Instance of the  class.
                    *other_vortices (list): List containing the other Vortex objects placed on the grid.
                    *dt            (float): Size of the time step to take. Needs to be small enough to avoid energy growth from
                                            euler forward method. Default is 0.001.
                                            
        -Return: None"""
        for vor in other_vortices:
            x0, y0 = self.center
            x1, y1 = vor.center
            distance = [x1-x0,y1-y0, 0]
            vorticity = [0,0,vor.fac]
            self.velocity_CM = np.cross(distance,vorticity)
            self.center = (x0+self.velocity_CM[0]*dt, y0+self.velocity_CM[1]*dt)
        self.place_vortex_on_grid()


@jit(nopython=True)
def velocity(r,R,u,k,X,Y,center):
    """Computes the velocity for points at a distance r from the center of the vortex assuming a Rankine vortex.
    Fucntion is jit using numba to speed up the process of solving on the whole grid  
    -Arguments: *self (Vortex object): Instance of the  class. 
                *r            (array): Distances from the center. Array is flatten for effeciency.
                *R            (float): The radius of the vortex
                *u            (array): Empty array of the size of flatten grid. This needs to be defined before hand for use of Numba.
                *k            (float): Angular velocity of vortex
                *X            (array): Flatten X-coord on grid
                *Y            (array): Flatten Y-coord on grid
                *center       (tuple): x and y coord of the center of the vortex.

    -Return: * u              (array): Flatten velocity of the fluid in x and y  at each grid point. """
    x0, y0 = center
    X = X.ravel()
    Y = Y.ravel()
    #u = np.zeros([2,len(r)])
    for i  in range(len(r)):
        if r[i] >= R:
            u_i = k/r[i]
        else:
            u_i = k*r[i]
        phi = np.arctan2((Y[i]-y0),(X[i]-x0))
        u[0][i] = -u_i*np.sin(phi)
        u[1][i] = u_i*np.cos(phi)
    u[0][:]= u[0][:]/np.max(u[0][:])
    u[1][:]= u[1][:]/np.max(u[1][:])
    return u
